{"version":3,"file":"edit-map-f2c55893.js","sources":["../../node_modules/@wordpress/element/build-module/create-interpolate-element.js","../../src/components/location-selector/ControlButtons.tsx","../../src/components/location-selector/LocationsList.tsx","../../src/components/LocationSelector.tsx","../../src/components/EditMap.tsx","../../src/edit-map.tsx"],"sourcesContent":["/**\n * Internal dependencies\n */\nimport { createElement, cloneElement, Fragment, isValidElement } from './react';\n\n/**\n * Object containing a React element.\n *\n * @typedef {import('react').ReactElement} Element\n */\n\nlet indoc, offset, output, stack;\n\n/**\n * Matches tags in the localized string\n *\n * This is used for extracting the tag pattern groups for parsing the localized\n * string and along with the map converting it to a react element.\n *\n * There are four references extracted using this tokenizer:\n *\n * match: Full match of the tag (i.e. <strong>, </strong>, <br/>)\n * isClosing: The closing slash, if it exists.\n * name: The name portion of the tag (strong, br) (if )\n * isSelfClosed: The slash on a self closing tag, if it exists.\n *\n * @type {RegExp}\n */\nconst tokenizer = /<(\\/)?(\\w+)\\s*(\\/)?>/g;\n\n/**\n * The stack frame tracking parse progress.\n *\n * @typedef Frame\n *\n * @property {Element}   element            A parent element which may still have\n * @property {number}    tokenStart         Offset at which parent element first\n *                                          appears.\n * @property {number}    tokenLength        Length of string marking start of parent\n *                                          element.\n * @property {number}    [prevOffset]       Running offset at which parsing should\n *                                          continue.\n * @property {number}    [leadingTextStart] Offset at which last closing element\n *                                          finished, used for finding text between\n *                                          elements.\n * @property {Element[]} children           Children.\n */\n\n/**\n * Tracks recursive-descent parse state.\n *\n * This is a Stack frame holding parent elements until all children have been\n * parsed.\n *\n * @private\n * @param {Element} element            A parent element which may still have\n *                                     nested children not yet parsed.\n * @param {number}  tokenStart         Offset at which parent element first\n *                                     appears.\n * @param {number}  tokenLength        Length of string marking start of parent\n *                                     element.\n * @param {number}  [prevOffset]       Running offset at which parsing should\n *                                     continue.\n * @param {number}  [leadingTextStart] Offset at which last closing element\n *                                     finished, used for finding text between\n *                                     elements.\n *\n * @return {Frame} The stack frame tracking parse progress.\n */\nfunction createFrame(element, tokenStart, tokenLength, prevOffset, leadingTextStart) {\n  return {\n    element,\n    tokenStart,\n    tokenLength,\n    prevOffset,\n    leadingTextStart,\n    children: []\n  };\n}\n\n/**\n * This function creates an interpolated element from a passed in string with\n * specific tags matching how the string should be converted to an element via\n * the conversion map value.\n *\n * @example\n * For example, for the given string:\n *\n * \"This is a <span>string</span> with <a>a link</a> and a self-closing\n * <CustomComponentB/> tag\"\n *\n * You would have something like this as the conversionMap value:\n *\n * ```js\n * {\n *     span: <span />,\n *     a: <a href={ 'https://github.com' } />,\n *     CustomComponentB: <CustomComponent />,\n * }\n * ```\n *\n * @param {string}                  interpolatedString The interpolation string to be parsed.\n * @param {Record<string, Element>} conversionMap      The map used to convert the string to\n *                                                     a react element.\n * @throws {TypeError}\n * @return {Element}  A wp element.\n */\nconst createInterpolateElement = (interpolatedString, conversionMap) => {\n  indoc = interpolatedString;\n  offset = 0;\n  output = [];\n  stack = [];\n  tokenizer.lastIndex = 0;\n  if (!isValidConversionMap(conversionMap)) {\n    throw new TypeError('The conversionMap provided is not valid. It must be an object with values that are React Elements');\n  }\n  do {\n    // twiddle our thumbs\n  } while (proceed(conversionMap));\n  return createElement(Fragment, null, ...output);\n};\n\n/**\n * Validate conversion map.\n *\n * A map is considered valid if it's an object and every value in the object\n * is a React Element\n *\n * @private\n *\n * @param {Object} conversionMap The map being validated.\n *\n * @return {boolean}  True means the map is valid.\n */\nconst isValidConversionMap = conversionMap => {\n  const isObject = typeof conversionMap === 'object';\n  const values = isObject && Object.values(conversionMap);\n  return isObject && values.length && values.every(element => isValidElement(element));\n};\n\n/**\n * This is the iterator over the matches in the string.\n *\n * @private\n *\n * @param {Object} conversionMap The conversion map for the string.\n *\n * @return {boolean} true for continuing to iterate, false for finished.\n */\nfunction proceed(conversionMap) {\n  const next = nextToken();\n  const [tokenType, name, startOffset, tokenLength] = next;\n  const stackDepth = stack.length;\n  const leadingTextStart = startOffset > offset ? offset : null;\n  if (!conversionMap[name]) {\n    addText();\n    return false;\n  }\n  switch (tokenType) {\n    case 'no-more-tokens':\n      if (stackDepth !== 0) {\n        const {\n          leadingTextStart: stackLeadingText,\n          tokenStart\n        } = stack.pop();\n        output.push(indoc.substr(stackLeadingText, tokenStart));\n      }\n      addText();\n      return false;\n    case 'self-closed':\n      if (0 === stackDepth) {\n        if (null !== leadingTextStart) {\n          output.push(indoc.substr(leadingTextStart, startOffset - leadingTextStart));\n        }\n        output.push(conversionMap[name]);\n        offset = startOffset + tokenLength;\n        return true;\n      }\n\n      // Otherwise we found an inner element.\n      addChild(createFrame(conversionMap[name], startOffset, tokenLength));\n      offset = startOffset + tokenLength;\n      return true;\n    case 'opener':\n      stack.push(createFrame(conversionMap[name], startOffset, tokenLength, startOffset + tokenLength, leadingTextStart));\n      offset = startOffset + tokenLength;\n      return true;\n    case 'closer':\n      // If we're not nesting then this is easy - close the block.\n      if (1 === stackDepth) {\n        closeOuterElement(startOffset);\n        offset = startOffset + tokenLength;\n        return true;\n      }\n\n      // Otherwise we're nested and we have to close out the current\n      // block and add it as a innerBlock to the parent.\n      const stackTop = stack.pop();\n      const text = indoc.substr(stackTop.prevOffset, startOffset - stackTop.prevOffset);\n      stackTop.children.push(text);\n      stackTop.prevOffset = startOffset + tokenLength;\n      const frame = createFrame(stackTop.element, stackTop.tokenStart, stackTop.tokenLength, startOffset + tokenLength);\n      frame.children = stackTop.children;\n      addChild(frame);\n      offset = startOffset + tokenLength;\n      return true;\n    default:\n      addText();\n      return false;\n  }\n}\n\n/**\n * Grabs the next token match in the string and returns it's details.\n *\n * @private\n *\n * @return {Array}  An array of details for the token matched.\n */\nfunction nextToken() {\n  const matches = tokenizer.exec(indoc);\n  // We have no more tokens.\n  if (null === matches) {\n    return ['no-more-tokens'];\n  }\n  const startedAt = matches.index;\n  const [match, isClosing, name, isSelfClosed] = matches;\n  const length = match.length;\n  if (isSelfClosed) {\n    return ['self-closed', name, startedAt, length];\n  }\n  if (isClosing) {\n    return ['closer', name, startedAt, length];\n  }\n  return ['opener', name, startedAt, length];\n}\n\n/**\n * Pushes text extracted from the indoc string to the output stack given the\n * current rawLength value and offset (if rawLength is provided ) or the\n * indoc.length and offset.\n *\n * @private\n */\nfunction addText() {\n  const length = indoc.length - offset;\n  if (0 === length) {\n    return;\n  }\n  output.push(indoc.substr(offset, length));\n}\n\n/**\n * Pushes a child element to the associated parent element's children for the\n * parent currently active in the stack.\n *\n * @private\n *\n * @param {Frame} frame The Frame containing the child element and it's\n *                      token information.\n */\nfunction addChild(frame) {\n  const {\n    element,\n    tokenStart,\n    tokenLength,\n    prevOffset,\n    children\n  } = frame;\n  const parent = stack[stack.length - 1];\n  const text = indoc.substr(parent.prevOffset, tokenStart - parent.prevOffset);\n  if (text) {\n    parent.children.push(text);\n  }\n  parent.children.push(cloneElement(element, null, ...children));\n  parent.prevOffset = prevOffset ? prevOffset : tokenStart + tokenLength;\n}\n\n/**\n * This is called for closing tags. It creates the element currently active in\n * the stack.\n *\n * @private\n *\n * @param {number} endOffset Offset at which the closing tag for the element\n *                           begins in the string. If this is greater than the\n *                           prevOffset attached to the element, then this\n *                           helps capture any remaining nested text nodes in\n *                           the element.\n */\nfunction closeOuterElement(endOffset) {\n  const {\n    element,\n    leadingTextStart,\n    prevOffset,\n    tokenStart,\n    children\n  } = stack.pop();\n  const text = endOffset ? indoc.substr(prevOffset, endOffset - prevOffset) : indoc.substr(prevOffset);\n  if (text) {\n    children.push(text);\n  }\n  if (null !== leadingTextStart) {\n    output.push(indoc.substr(leadingTextStart, tokenStart - leadingTextStart));\n  }\n  output.push(cloneElement(element, null, ...children));\n}\nexport default createInterpolateElement;\n//# sourceMappingURL=create-interpolate-element.js.map","import {__} from '@wordpress/i18n'\n\ntype Props = {\n    onClickAdd?: () => void\n    onClickRemove?: () => void\n}\n\nexport default function ControlButtons(props: Props) {\n    const {onClickAdd, onClickRemove} = props\n\n    return (\n        <div className=\"control-buttons\">\n            <button\n                className=\"button\"\n                onClick={() => onClickRemove && onClickRemove()}\n                title={__('제외하기', 'shoplic-integration-for-naver-map')}\n                type=\"button\"\n            >\n                &#9664;\n            </button>\n            <button\n                className=\"button\"\n                onClick={() => onClickAdd && onClickAdd()}\n                title={__('포함하기', 'shoplic-integration-for-naver-map')}\n                type=\"button\"\n            >\n                &#9654;\n            </button>\n        </div>\n    )\n}\n","import {joinClassNames} from '../../libs/helper.ts'\nimport {LocationSet, MapLocationProps} from '../../types'\n\ntype Props = {\n    locations?: MapLocationProps[]\n    className?: string\n    label?: string\n    name?: string\n    onChange?: (ids: number[]) => void\n    selected?: LocationSet\n}\n\nfunction formatMapLocation(mapLocation: MapLocationProps) {\n    let output = mapLocation.title\n\n    if (mapLocation.address) {\n        output += ` (${mapLocation.address})`\n    }\n\n    return output\n}\n\nexport default function LocationsList(props: Props) {\n    const {\n        locations,\n        className,\n        label,\n        name,\n        onChange,\n        selected,\n    } = props\n\n    return (\n        <div className={`${joinClassNames('locations-list-wrap', className)}`}>\n            <h3 className=\"label\">{label}</h3>\n            <select\n                className={`${joinClassNames('locations-list', className)}`}\n                multiple={true}\n                name={name}\n                onChange={(e) => {\n                    const selected: number[] = []\n                    for (const option of e.target.selectedOptions) {\n                        const value = parseInt(option.value)\n                        if (!isNaN(value)) {\n                            selected.push(value)\n                        }\n                    }\n                    onChange && onChange(selected)\n                }}\n                value={[...(selected?.values() ?? [])].map((value) => value.toString())}\n            >\n                {locations?.map((mapLocation: MapLocationProps) => (\n                    <option\n                        key={mapLocation.id}\n                        title={formatMapLocation(mapLocation)}\n                        value={mapLocation.id}\n                    >\n                        {formatMapLocation(mapLocation)}\n                    </option>\n                ))}\n            </select>\n        </div>\n    )\n}\n","// Library.\nimport {useState} from 'react'\nimport {__} from '@wordpress/i18n'\n// Ours.\nimport ControlButtons from './location-selector/ControlButtons'\nimport LocationsList from './location-selector/LocationsList'\n// Types.\nimport {LocationSet, MapLocationProps} from '../types'\n\ntype Props = {\n    locations: MapLocationProps[]\n    onChange: (values: LocationSet) => void\n    values: LocationSet\n}\n\nexport default function LocationSelector(props: Props) {\n    const {\n        locations: propLocations,\n        onChange,\n        values: propValues,\n    } = props\n\n    const [allLocations, setAllLocations] = useState<LocationSet>(new Set<number>()),\n        [selectedLocations, setSelectedLocations] = useState<LocationSet>(new Set<number>())\n\n    return (\n        <div className=\"location-selector-wrap\">\n            <LocationsList\n                className=\"all-locations\"\n                label={__('선택 가능한 위치', 'shoplic-integration-for-naver-map')}\n                locations={propLocations.filter((location) => !propValues.has(location.id))}\n                onChange={(values: number[]) => {\n                    setAllLocations(new Set(values))\n                }}\n                selected={allLocations}\n            />\n            <ControlButtons\n                onClickAdd={() => {\n                    // Setup new values.\n                    const newValues = new Set(propValues)\n                    allLocations.forEach((id) => {\n                        if (!newValues.has(id)) {\n                            newValues.add(id)\n                        }\n                    })\n                    onChange(newValues)\n                    // Reset.\n                    setAllLocations(new Set())\n                }}\n                onClickRemove={() => {\n                    // Setup new values.\n                    const newValues = new Set(propValues)\n                    selectedLocations.forEach((id) => {\n                        if (newValues.has(id)) {\n                            newValues.delete(id)\n                        }\n                    })\n                    onChange(newValues)\n                    // Reset.\n                    setSelectedLocations(new Set())\n                }}\n            />\n            <LocationsList\n                className=\"selected-locations\"\n                label={__('선택된 위치', 'shoplic-integration-for-naver-map')}\n                locations={propLocations.filter((location) => propValues.has(location.id))}\n                onChange={(values: number[]) => {\n                    setSelectedLocations(new Set(values))\n                }}\n                selected={selectedLocations}\n            />\n        </div>\n    )\n}\n","// Library\nimport {useState} from 'react'\nimport {createInterpolateElement} from '@wordpress/element'\nimport {__} from '@wordpress/i18n'\n// Ours.\nimport LocationSelector from './LocationSelector.tsx'\nimport {Description, Nonce} from './form'\nimport {NaverMap, Marker} from './map'\nimport {getCenter} from '../libs/helper.ts'\n// Types.\nimport {LocationSet, MapProps} from '../types'\n// Style.\nimport '../styles/edit-map.css'\n\ntype Props = {\n    data: MapProps\n    nonce: string\n    postId: number\n}\n\nexport default function EditMap(props: Props) {\n    const [locations, setLocations] = useState<LocationSet>(new Set(props.data.locations)),\n        [map, setMap] = useState<naver.maps.Map | null>(null)\n\n    return (\n        <div id=\"edit-map-wrap\">\n            <NaverMap\n                id=\"edit-map\"\n                className={`naver-map edit-map edit-map-${props.postId}`}\n                mapOptions={{\n                    center: getCenter(props.data.allLocations.map((location) => location.coord)),\n                    disableKineticPan: false,\n                    tileTransition: true,\n                    zoom: 10\n                }}\n                ref={(_map: naver.maps.Map | null) => setMap(() => _map)}\n                style={{\n                    height: '480px'\n                }}\n            >\n                {\n                    map && props.data.allLocations\n                        .filter((location) => locations.has(location.id))\n                        .map((location) => {\n                            return (\n                                <Marker\n                                    key={location.id}\n                                    markerOptions={{\n                                        map: map,\n                                        position: location.coord\n                                    }}\n                                />\n                            )\n                        })\n                }\n            </NaverMap>\n            <LocationSelector\n                locations={props.data.allLocations}\n                onChange={(values: LocationSet) => {\n                    setLocations(values)\n                }}\n                values={locations}\n            />\n            <Description>\n                {createInterpolateElement(\n                    __('<kbd>Ctrl</kbd> 키를 눌러 복수의 항목을 선택할 수 있습니다.', 'naver_maps'),\n                    {kbd: <kbd/>}\n                )}\n            </Description>\n            {/* Hidden form fields. */}\n            {[...locations.values()].map((location: number, idx: number) => (\n                <input\n                    id={`map-locations-${idx}`}\n                    key={idx}\n                    name=\"nm_map_locations[]\"\n                    type=\"hidden\"\n                    defaultValue={location}\n                />\n            ))}\n            {/* Nonce is here! */}\n            <Nonce\n                id=\"nm-map-nonce\"\n                name=\"nm_map_nonce\"\n                defaultValue={props.nonce}\n            />\n        </div>\n    )\n}\n","// Vite.\nimport 'vite/modulepreload-polyfill'\n// Library.\nimport {StrictMode} from 'react'\nimport {createRoot} from 'react-dom/client'\n// Src.\nimport EditMap from './components/EditMap.tsx'\nimport {l10nHelper} from './libs/helper.ts'\n\nconst {\n    data,\n    nonce,\n    post_id,\n} = nmEditMap\n\nconsole.log('nmEditMap', nmEditMap)\n\nconst root = document.getElementById('nm-edit-map')\nif (root) {\n    l10nHelper('shoplic-integration-for-naver-map')\n    createRoot(root).render(\n        <StrictMode>\n            <EditMap data={data} nonce={nonce} postId={parseInt(post_id)}/>\n        </StrictMode>\n    )\n} else {\n    console.error('#nm-edit-map not found!')\n}"],"names":["createElement","Fragment","isValidElement","cloneElement","jsxs","jsx","output","selected","useState","createInterpolateElement","StrictMode"],"mappings":"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","x_google_ignoreList":[0]}